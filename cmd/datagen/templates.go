package main

//go:generate embed file --var redblackbstMap --source ../../map/redblackbst/rbbst.go
//go:generate embed file --var redblackbstSet --source ../../set/redblackbst/rbbst.go

const (
	redblackbstMap = "package redblackbst\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// RedBlack is a sorted map built on a left leaning red black balanced\n// search sorted map. It stores VType values, keyed by KType.\ntype RedBlack struct {\n\troot *treenode\n}\n\nfunc (r RedBlack) compare(a, b KType) int { return a.Compare(b) }\n\n// NewRedBlack creates a sorted map.\nfunc NewRedBlack() *RedBlack { return &RedBlack{} }\n\n// IsEmpty tells if the sorted map contains no key/value.\nfunc (r RedBlack) IsEmpty() bool {\n\treturn r.root == nil\n}\n\n// Size of the sorted map.\nfunc (r RedBlack) Size() int { return r.root.size() }\n\n// Clear all the values in the sorted map.\nfunc (r *RedBlack) Clear() { r.root = nil }\n\n// Put a value in the sorted map at key `k`. The old value at `k` is returned\n// if the key was already present.\nfunc (r *RedBlack) Put(k KType, v VType) (old VType, overwrite bool) {\n\tr.root, old, overwrite = r.put(r.root, k, v)\n\treturn\n}\n\nfunc (r *RedBlack) put(h *treenode, k KType, v VType) (_ *treenode, old VType, overwrite bool) {\n\tif h == nil {\n\t\tn := &treenode{key: k, val: v, n: 1, colorRed: true}\n\t\treturn n, old, overwrite\n\t}\n\n\tcmp := r.compare(k, h.key)\n\tif cmp < 0 {\n\t\th.left, old, overwrite = r.put(h.left, k, v)\n\t} else if cmp > 0 {\n\t\th.right, old, overwrite = r.put(h.right, k, v)\n\t} else {\n\t\toverwrite = true\n\t\told = h.val\n\t\th.val = v\n\t}\n\n\tif h.right.isRed() && !h.left.isRed() {\n\t\th = r.rotateLeft(h)\n\t}\n\tif h.left.isRed() && h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.left.isRed() && h.right.isRed() {\n\t\tr.flipColors(h)\n\t}\n\th.n = h.left.size() + h.right.size() + 1\n\treturn h, old, overwrite\n}\n\n// Get a value from the sorted map at key `k`. Returns false\n// if the key doesn't exist.\nfunc (r RedBlack) Get(k KType) (VType, bool) {\n\treturn r.loopGet(r.root, k)\n}\n\nfunc (r RedBlack) loopGet(h *treenode, k KType) (v VType, ok bool) {\n\tfor h != nil {\n\t\tcmp := r.compare(k, h.key)\n\t\tif cmp == 0 {\n\t\t\treturn h.val, true\n\t\t} else if cmp < 0 {\n\t\t\th = h.left\n\t\t} else if cmp > 0 {\n\t\t\th = h.right\n\t\t}\n\t}\n\treturn\n}\n\n// Has tells if a value exists at key `k`. This is short hand for `Get.\nfunc (r RedBlack) Has(k KType) bool {\n\t_, ok := r.loopGet(r.root, k)\n\treturn ok\n}\n\n// Min returns the smallest key/value in the sorted map, if it exists.\nfunc (r RedBlack) Min() (k KType, v VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := r.min(r.root)\n\treturn h.key, h.val, true\n}\n\nfunc (r RedBlack) min(x *treenode) *treenode {\n\tif x.left == nil {\n\t\treturn x\n\t}\n\treturn r.min(x.left)\n}\n\n// Max returns the largest key/value in the sorted map, if it exists.\nfunc (r RedBlack) Max() (k KType, v VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := r.max(r.root)\n\treturn h.key, h.val, true\n}\n\nfunc (r RedBlack) max(x *treenode) *treenode {\n\tif x.right == nil {\n\t\treturn x\n\t}\n\treturn r.max(x.right)\n}\n\n// Floor returns the largest key/value in the sorted map that is smaller than\n// `k`.\nfunc (r RedBlack) Floor(key KType) (k KType, v VType, ok bool) {\n\tx := r.floor(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc (r RedBlack) floor(h *treenode, k KType) *treenode {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp < 0 {\n\t\treturn r.floor(h.left, k)\n\t}\n\tt := r.floor(h.right, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Ceiling returns the smallest key/value in the sorted map that is larger than\n// `k`.\nfunc (r RedBlack) Ceiling(key KType) (k KType, v VType, ok bool) {\n\tx := r.ceiling(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc (r RedBlack) ceiling(h *treenode, k KType) *treenode {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp > 0 {\n\t\treturn r.ceiling(h.right, k)\n\t}\n\tt := r.ceiling(h.left, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Select key of rank k, meaning the k-th biggest KType in the sorted map.\nfunc (r RedBlack) Select(key int) (k KType, v VType, ok bool) {\n\tx := r.nodeselect(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc (r RedBlack) nodeselect(x *treenode, k int) *treenode {\n\tif x == nil {\n\t\treturn nil\n\t}\n\tt := x.left.size()\n\tif t > k {\n\t\treturn r.nodeselect(x.left, k)\n\t} else if t < k {\n\t\treturn r.nodeselect(x.right, k-t-1)\n\t} else {\n\t\treturn x\n\t}\n}\n\n// Rank is the number of keys less than `k`.\nfunc (r RedBlack) Rank(k KType) int {\n\treturn r.keyrank(k, r.root)\n}\n\nfunc (r RedBlack) keyrank(k KType, h *treenode) int {\n\tif h == nil {\n\t\treturn 0\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp < 0 {\n\t\treturn r.keyrank(k, h.left)\n\t} else if cmp > 0 {\n\t\treturn 1 + h.left.size() + r.keyrank(k, h.right)\n\t} else {\n\t\treturn h.left.size()\n\t}\n}\n\n// Keys visit each keys in the sorted map, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) Keys(visit func(KType, VType) bool) {\n\tmin, _, ok := r.Min()\n\tif !ok {\n\t\treturn\n\t}\n\t// if the min exists, then the max must exist\n\tmax, _, _ := r.Max()\n\tr.RangedKeys(min, max, visit)\n}\n\n// RangedKeys visit each keys between lo and hi in the sorted map, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) RangedKeys(lo, hi KType, visit func(KType, VType) bool) {\n\tr.keys(r.root, visit, lo, hi)\n}\n\nfunc (r RedBlack) keys(h *treenode, visit func(KType, VType) bool, lo, hi KType) bool {\n\tif h == nil {\n\t\treturn true\n\t}\n\tcmplo := r.compare(lo, h.key)\n\tcmphi := r.compare(hi, h.key)\n\tif cmplo < 0 {\n\t\tif !r.keys(h.left, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmplo <= 0 && cmphi >= 0 {\n\t\tif !visit(h.key, h.val) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmphi > 0 {\n\t\tif !r.keys(h.right, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// DeleteMin removes the smallest key and its value from the sorted map.\nfunc (r *RedBlack) DeleteMin() (oldk KType, oldv VType, ok bool) {\n\tr.root, oldk, oldv, ok = r.deleteMin(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) deleteMin(h *treenode) (_ *treenode, oldk KType, oldv VType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, oldv, false\n\t}\n\n\tif h.left == nil {\n\t\treturn nil, h.key, h.val, true\n\t}\n\tif !h.left.isRed() && !h.left.left.isRed() {\n\t\th = r.moveRedLeft(h)\n\t}\n\th.left, oldk, oldv, ok = r.deleteMin(h.left)\n\treturn r.balance(h), oldk, oldv, ok\n}\n\n// DeleteMax removes the largest key and its value from the sorted map.\nfunc (r *RedBlack) DeleteMax() (oldk KType, oldv VType, ok bool) {\n\tr.root, oldk, oldv, ok = r.deleteMax(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) deleteMax(h *treenode) (_ *treenode, oldk KType, oldv VType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, oldv, ok\n\t}\n\tif h.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.right == nil {\n\t\treturn nil, h.key, h.val, true\n\t}\n\tif !h.right.isRed() && !h.right.left.isRed() {\n\t\th = r.moveRedRight(h)\n\t}\n\th.right, oldk, oldv, ok = r.deleteMax(h.right)\n\treturn r.balance(h), oldk, oldv, ok\n}\n\n// Delete key `k` from sorted map, if it exists.\nfunc (r *RedBlack) Delete(k KType) (old VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\tr.root, old, ok = r.delete(r.root, k)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) delete(h *treenode, k KType) (_ *treenode, old VType, ok bool) {\n\n\tif h == nil {\n\t\treturn h, old, false\n\t}\n\n\tif r.compare(k, h.key) < 0 {\n\t\tif h.left == nil {\n\t\t\treturn h, old, false\n\t\t}\n\n\t\tif !h.left.isRed() && !h.left.left.isRed() {\n\t\t\th = r.moveRedLeft(h)\n\t\t}\n\n\t\th.left, old, ok = r.delete(h.left, k)\n\t\th = r.balance(h)\n\t\treturn h, old, ok\n\t}\n\n\tif h.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\n\tif r.compare(k, h.key) == 0 && h.right == nil {\n\t\treturn nil, h.val, true\n\t}\n\n\tif h.right != nil && !h.right.isRed() && !h.right.left.isRed() {\n\t\th = r.moveRedRight(h)\n\t}\n\n\tif r.compare(k, h.key) == 0 {\n\n\t\tvar subk KType\n\t\tvar subv VType\n\t\th.right, subk, subv, ok = r.deleteMin(h.right)\n\n\t\told, h.key, h.val = h.val, subk, subv\n\t\tok = true\n\t} else {\n\t\th.right, old, ok = r.delete(h.right, k)\n\t}\n\n\th = r.balance(h)\n\treturn h, old, ok\n}\n\n// deletions\n\nfunc (r *RedBlack) moveRedLeft(h *treenode) *treenode {\n\tr.flipColors(h)\n\tif h.right.left.isRed() {\n\t\th.right = r.rotateRight(h.right)\n\t\th = r.rotateLeft(h)\n\t\tr.flipColors(h)\n\t}\n\treturn h\n}\n\nfunc (r *RedBlack) moveRedRight(h *treenode) *treenode {\n\tr.flipColors(h)\n\tif h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t\tr.flipColors(h)\n\t}\n\treturn h\n}\n\nfunc (r *RedBlack) balance(h *treenode) *treenode {\n\tif h.right.isRed() {\n\t\th = r.rotateLeft(h)\n\t}\n\tif h.left.isRed() && h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.left.isRed() && h.right.isRed() {\n\t\tr.flipColors(h)\n\t}\n\th.n = h.left.size() + h.right.size() + 1\n\treturn h\n}\n\nfunc (r *RedBlack) rotateLeft(h *treenode) *treenode {\n\tx := h.right\n\th.right = x.left\n\tx.left = h\n\tx.colorRed = h.colorRed\n\th.colorRed = true\n\tx.n = h.n\n\th.n = 1 + h.left.size() + h.right.size()\n\treturn x\n}\n\nfunc (r *RedBlack) rotateRight(h *treenode) *treenode {\n\tx := h.left\n\th.left = x.right\n\tx.right = h\n\tx.colorRed = h.colorRed\n\th.colorRed = true\n\tx.n = h.n\n\th.n = 1 + h.left.size() + h.right.size()\n\treturn x\n}\n\nfunc (r *RedBlack) flipColors(h *treenode) {\n\th.colorRed = !h.colorRed\n\th.left.colorRed = !h.left.colorRed\n\th.right.colorRed = !h.right.colorRed\n}\n\n// nodes\n\ntype treenode struct {\n\tkey         KType\n\tval         VType\n\tleft, right *treenode\n\tn           int\n\tcolorRed    bool\n}\n\nfunc (x *treenode) isRed() bool { return (x != nil) && (x.colorRed == true) }\n\nfunc (x *treenode) size() int {\n\tif x == nil {\n\t\treturn 0\n\t}\n\treturn x.n\n}\n\n// debugging\n\n// DotGraph exports the sorted map into DOT format.\nfunc (r RedBlack) DotGraph(out io.Writer, name string) (int, error) {\n\treturn r.dotGraph(r.root, out, name)\n}\n\nfunc (r RedBlack) dotGraph(h *treenode, out io.Writer, name string) (n int, err error) {\n\tnodes := bytes.NewBuffer(nil)\n\tedges := bytes.NewBuffer(nil)\n\n\tfmt.Fprintf(nodes, \"digraph %q {\\n\", name)\n\tfmt.Fprintf(edges, \"\\t%q -> \", name)\n\tr.dotvisit(h, nodes, edges, true)\n\tfmt.Fprintf(edges, \"}\\n\")\n\n\tedges.WriteTo(nodes)\n\n\treturn out.Write(nodes.Bytes())\n}\n\nfunc (r RedBlack) dotvisit(x *treenode, nodes io.Writer, edges *bytes.Buffer, isLeft bool) {\n\n\tvar color string\n\tif x.isRed() {\n\t\tcolor = \"red\"\n\t} else {\n\t\tcolor = \"black\"\n\t}\n\n\tvar direction string\n\tif isLeft {\n\t\tdirection = \"left\"\n\t} else {\n\t\tdirection = \"right\"\n\t}\n\n\tif x == nil {\n\t\tfmt.Fprintf(edges, \"nil [label=%q, color=%s];\\n\", direction, color)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(edges, \"\\\"%p\\\" [label=%q, color=%s];\\n\", x, direction, color)\n\tfmt.Fprintf(nodes, \"\\t\\\"%p\\\" [label=\\\"%v\\\", shape = circle, color=%s];\\n\", x, x.key, color)\n\n\tfmt.Fprintf(edges, \"\\t\\\"%p\\\" -> \", x)\n\tr.dotvisit(x.left, nodes, edges, true)\n\tfmt.Fprintf(edges, \"\\t\\\"%p\\\" -> \", x)\n\tr.dotvisit(x.right, nodes, edges, false)\n}\n"
	redblackbstSet string
)
