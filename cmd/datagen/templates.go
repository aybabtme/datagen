package main

//go:generate embed file --var redblackbst --source ../../redblackbst/rbbst.go
const (
	redblackbst = "package redblackbst\n\n// RedBlack is a sorted map built on a left leaning red black balanced\n// search sorted map. It stores VType values, keyed by KType.\ntype RedBlack struct {\n\troot *node\n}\n\n// New creates a sorted map.\nfunc New() *RedBlack { return &RedBlack{} }\n\n// IsEmpty tells if the sorted map contains no key/value.\nfunc (r RedBlack) IsEmpty() bool {\n\treturn r.root == nil\n}\n\n// Size of the sorted map.\nfunc (r RedBlack) Size() int { return size(r.root) }\n\n// Clear all the values in the sorted map.\nfunc (r *RedBlack) Clear() { r.root = nil }\n\n// Put a value in the sorted map at key `k`. The old value at `k` is returned\n// if the key was already present.\nfunc (r *RedBlack) Put(k KType, v VType) (old VType, overwrite bool) {\n\tr.root, old, overwrite = put(r.root, k, v)\n\treturn\n}\n\nfunc put(h *node, k KType, v VType) (_ *node, old VType, overwrite bool) {\n\tif h == nil {\n\t\treturn newNode(k, v, 1, red), old, overwrite\n\t}\n\n\tcmp := k.Compare(h.key)\n\tif cmp < 0 {\n\t\th.left, old, overwrite = put(h.left, k, v)\n\t} else if cmp > 0 {\n\t\th.right, old, overwrite = put(h.right, k, v)\n\t} else {\n\t\toverwrite = true\n\t\told = h.val\n\t\th.val = v\n\t}\n\n\tif isRed(h.right) && !isRed(h.left) {\n\t\th = rotateLeft(h)\n\t}\n\tif isRed(h.left) && isRed(h.left.left) {\n\t\th = rotateRight(h)\n\t}\n\tif isRed(h.left) && isRed(h.right) {\n\t\tflipColors(h)\n\t}\n\th.n = size(h.left) + size(h.right) + 1\n\treturn h, old, overwrite\n}\n\n// Get a value from the sorted map at key `k`. Returns false\n// if the key doesn't exist.\nfunc (r RedBlack) Get(k KType) (VType, bool) {\n\treturn loopGet(r.root, k)\n}\n\nfunc loopGet(h *node, k KType) (v VType, ok bool) {\n\tfor h != nil {\n\t\tcmp := k.Compare(h.key)\n\t\tif cmp == 0 {\n\t\t\treturn h.val, true\n\t\t} else if cmp < 0 {\n\t\t\th = h.left\n\t\t} else if cmp > 0 {\n\t\t\th = h.right\n\t\t}\n\t}\n\treturn\n}\n\n// Has tells if a value exists at key `k`. This is short hand for `Get.\nfunc (r RedBlack) Has(k KType) bool {\n\t_, ok := loopGet(r.root, k)\n\treturn ok\n}\n\n// Min returns the smallest key/value in the sorted map, if it exists.\nfunc (r RedBlack) Min() (k KType, v VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := min(r.root)\n\treturn h.key, h.val, true\n}\n\nfunc min(x *node) *node {\n\tif x.left == nil {\n\t\treturn x\n\t}\n\treturn min(x.left)\n}\n\n// Max returns the largest key/value in the sorted map, if it exists.\nfunc (r RedBlack) Max() (k KType, v VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := max(r.root)\n\treturn h.key, h.val, true\n}\n\nfunc max(x *node) *node {\n\tif x.right == nil {\n\t\treturn x\n\t}\n\treturn max(x.right)\n}\n\n// Floor returns the largest key/value in the sorted map that is smaller than\n// `k`.\nfunc (r RedBlack) Floor(key KType) (k KType, v VType, ok bool) {\n\tx := floor(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc floor(h *node, k KType) *node {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := k.Compare(h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp < 0 {\n\t\treturn floor(h.left, k)\n\t}\n\tt := floor(h.right, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Ceiling returns the smallest key/value in the sorted map that is larger than\n// `k`.\nfunc (r RedBlack) Ceiling(key KType) (k KType, v VType, ok bool) {\n\tx := ceiling(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc ceiling(h *node, k KType) *node {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := k.Compare(h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp > 0 {\n\t\treturn ceiling(h.right, k)\n\t}\n\tt := ceiling(h.left, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Select key of rank k, meaning the k-th biggest KType in the sorted map.\nfunc (r RedBlack) Select(key int) (k KType, v VType, ok bool) {\n\tx := nodeselect(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc nodeselect(x *node, k int) *node {\n\tif x == nil {\n\t\treturn nil\n\t}\n\tt := size(x.left)\n\tif t > k {\n\t\treturn nodeselect(x.left, k)\n\t} else if t < k {\n\t\treturn nodeselect(x.right, k-t-1)\n\t} else {\n\t\treturn x\n\t}\n}\n\n// Rank is the number of keys less than `k`.\nfunc (r RedBlack) Rank(k KType) int {\n\treturn keyrank(k, r.root)\n}\n\nfunc keyrank(k KType, h *node) int {\n\tif h == nil {\n\t\treturn 0\n\t}\n\tcmp := k.Compare(h.key)\n\tif cmp < 0 {\n\t\treturn keyrank(k, h.left)\n\t} else if cmp > 0 {\n\t\treturn 1 + size(h.left) + keyrank(k, h.right)\n\t} else {\n\t\treturn size(h.left)\n\t}\n}\n\n// Keys visit each keys in the sorted map, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) Keys(visit func(KType, VType) bool) {\n\tmin, _, ok := r.Min()\n\tif !ok {\n\t\treturn\n\t}\n\t// if the min exists, then the max must exist\n\tmax, _, _ := r.Max()\n\tr.RangedKeys(min, max, visit)\n}\n\n// RangedKeys visit each keys between lo and hi in the sorted map, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) RangedKeys(lo, hi KType, visit func(KType, VType) bool) {\n\tkeys(r.root, visit, lo, hi)\n}\n\nfunc keys(h *node, visit func(KType, VType) bool, lo, hi KType) bool {\n\tif h == nil {\n\t\treturn true\n\t}\n\tcmplo := lo.Compare(h.key)\n\tcmphi := hi.Compare(h.key)\n\tif cmplo < 0 {\n\t\tif !keys(h.left, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmplo <= 0 && cmphi >= 0 {\n\t\tif !visit(h.key, h.val) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmphi > 0 {\n\t\tif !keys(h.right, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// DeleteMin removes the smallest key and its value from the sorted map.\nfunc (r *RedBlack) DeleteMin() (oldk KType, oldv VType, ok bool) {\n\tr.root, oldk, oldv, ok = deleteMin(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.color = black\n\t}\n\treturn\n}\n\nfunc deleteMin(h *node) (_ *node, oldk KType, oldv VType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, oldv, false\n\t}\n\n\tif h.left == nil {\n\t\treturn nil, h.key, h.val, true\n\t}\n\tif !isRed(h.left) && !isRed(h.left.left) {\n\t\th = moveRedLeft(h)\n\t}\n\th.left, oldk, oldv, ok = deleteMin(h.left)\n\treturn balance(h), oldk, oldv, ok\n}\n\n// DeleteMax removes the largest key and its value from the sorted map.\nfunc (r *RedBlack) DeleteMax() (oldk KType, oldv VType, ok bool) {\n\tr.root, oldk, oldv, ok = deleteMax(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.color = black\n\t}\n\treturn\n}\n\nfunc deleteMax(h *node) (_ *node, oldk KType, oldv VType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, oldv, ok\n\t}\n\tif isRed(h.left) {\n\t\th = rotateRight(h)\n\t}\n\tif h.right == nil {\n\t\treturn nil, h.key, h.val, true\n\t}\n\tif !isRed(h.right) && !isRed(h.right.left) {\n\t\th = moveRedRight(h)\n\t}\n\th.right, oldk, oldv, ok = deleteMax(h.right)\n\treturn balance(h), oldk, oldv, ok\n}\n\n// Delete key `k` from sorted map, if it exists.\nfunc (r *RedBlack) Delete(k KType) (old VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\tr.root, old, ok = delete(r.root, k)\n\tif !r.IsEmpty() {\n\t\tr.root.color = black\n\t}\n\treturn\n}\n\nfunc delete(h *node, k KType) (_ *node, old VType, ok bool) {\n\n\tif h == nil {\n\t\treturn h, old, false\n\t}\n\n\tif k.Compare(h.key) < 0 {\n\t\tif h.left == nil {\n\t\t\treturn h, old, false\n\t\t}\n\n\t\tif !isRed(h.left) && !isRed(h.left.left) {\n\t\t\th = moveRedLeft(h)\n\t\t}\n\n\t\th.left, old, ok = delete(h.left, k)\n\t\th = balance(h)\n\t\treturn h, old, ok\n\t}\n\n\tif isRed(h.left) {\n\t\th = rotateRight(h)\n\t}\n\n\tif k.Compare(h.key) == 0 && h.right == nil {\n\t\treturn nil, h.val, true\n\t}\n\n\tif h.right != nil && !isRed(h.right) && !isRed(h.right.left) {\n\t\th = moveRedRight(h)\n\t}\n\n\tif k.Compare(h.key) == 0 {\n\n\t\tvar subk KType\n\t\tvar subv VType\n\t\th.right, subk, subv, ok = deleteMin(h.right)\n\n\t\told, h.key, h.val = h.val, subk, subv\n\t\tok = true\n\t} else {\n\t\th.right, old, ok = delete(h.right, k)\n\t}\n\n\th = balance(h)\n\treturn h, old, ok\n}\n\n// deletions\n\nfunc moveRedLeft(h *node) *node {\n\tflipColors(h)\n\tif isRed(h.right.left) {\n\t\th.right = rotateRight(h.right)\n\t\th = rotateLeft(h)\n\t\tflipColors(h)\n\t}\n\treturn h\n}\n\nfunc moveRedRight(h *node) *node {\n\tflipColors(h)\n\tif isRed(h.left.left) {\n\t\th = rotateRight(h)\n\t\tflipColors(h)\n\t}\n\treturn h\n}\n\nfunc balance(h *node) *node {\n\tif isRed(h.right) {\n\t\th = rotateLeft(h)\n\t}\n\tif isRed(h.left) && isRed(h.left.left) {\n\t\th = rotateRight(h)\n\t}\n\tif isRed(h.left) && isRed(h.right) {\n\t\tflipColors(h)\n\t}\n\th.n = size(h.left) + size(h.right) + 1\n\treturn h\n}\n\n// nodes\n\nconst (\n\tred   = true\n\tblack = false\n)\n\ntype node struct {\n\tkey         KType\n\tval         VType\n\tleft, right *node\n\tn           int\n\tcolor       bool\n}\n\nfunc newNode(k KType, v VType, n int, color bool) *node {\n\treturn &node{key: k, val: v, n: n, color: color}\n}\n\nfunc isRed(x *node) bool { return (x != nil) && (x.color == red) }\n\nfunc rotateLeft(h *node) *node {\n\tx := h.right\n\th.right = x.left\n\tx.left = h\n\tx.color = h.color\n\th.color = red\n\tx.n = h.n\n\th.n = 1 + size(h.left) + size(h.right)\n\treturn x\n}\n\nfunc rotateRight(h *node) *node {\n\tx := h.left\n\th.left = x.right\n\tx.right = h\n\tx.color = h.color\n\th.color = red\n\tx.n = h.n\n\th.n = 1 + size(h.left) + size(h.right)\n\treturn x\n}\n\nfunc flipColors(h *node) {\n\th.color = !h.color\n\th.left.color = !h.left.color\n\th.right.color = !h.right.color\n}\n\nfunc size(x *node) int {\n\tif x == nil {\n\t\treturn 0\n\t}\n\treturn x.n\n}\n"
)
