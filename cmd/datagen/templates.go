package main

//go:generate embed file --var redblackbstMapSrc --source ../../map/redblackbst/rbbst.go
//go:generate embed file --var redblackbstSetSrc --source ../../set/redblackbst/rbbst.go
//go:generate embed file --var heapSrc --source ../../heap/heap.go
//go:generate embed file --var queueSrc --source ../../queue/queue.go

const (
	redblackbstMapSrc = "package redblackbst\n\nfunc (r RedBlack) compare(a, b KType) int { return a.Compare(b) }\n\n// RedBlack is a sorted map built on a left leaning red black balanced\n// search sorted map. It stores VType values, keyed by KType.\ntype RedBlack struct {\n\troot *mapnode\n}\n\n// NewRedBlack creates a sorted map.\nfunc NewRedBlack() *RedBlack { return &RedBlack{} }\n\n// IsEmpty tells if the sorted map contains no key/value.\nfunc (r RedBlack) IsEmpty() bool {\n\treturn r.root == nil\n}\n\n// Size of the sorted map.\nfunc (r RedBlack) Size() int { return r.root.size() }\n\n// Clear all the values in the sorted map.\nfunc (r *RedBlack) Clear() { r.root = nil }\n\n// Put a value in the sorted map at key `k`. The old value at `k` is returned\n// if the key was already present.\nfunc (r *RedBlack) Put(k KType, v VType) (old VType, overwrite bool) {\n\tr.root, old, overwrite = r.put(r.root, k, func() VType { return v }, func(_ VType) VType { return v })\n\treturn\n}\n\n// Mutate is like a Put when `k` isn't defined, but allows you to create or mutate the value found at the location of `k`.\nfunc (r *RedBlack) Mutate(k KType, creator func() VType, mutator func(old VType) VType) {\n\tr.root, _, _ = r.put(r.root, k, creator, mutator)\n}\n\nfunc (r *RedBlack) put(h *mapnode, k KType, create func() VType, mutate func(old VType) VType) (_ *mapnode, old VType, overwrite bool) {\n\tif h == nil {\n\t\tn := &mapnode{key: k, val: create(), n: 1, colorRed: true}\n\t\treturn n, old, overwrite\n\t}\n\n\tcmp := r.compare(k, h.key)\n\tif cmp < 0 {\n\t\th.left, old, overwrite = r.put(h.left, k, create, mutate)\n\t} else if cmp > 0 {\n\t\th.right, old, overwrite = r.put(h.right, k, create, mutate)\n\t} else {\n\t\toverwrite = true\n\t\told = h.val\n\t\th.val = mutate(old)\n\t}\n\n\tif h.right.isRed() && !h.left.isRed() {\n\t\th = r.rotateLeft(h)\n\t}\n\tif h.left.isRed() && h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.left.isRed() && h.right.isRed() {\n\t\tr.flipColors(h)\n\t}\n\th.n = h.left.size() + h.right.size() + 1\n\treturn h, old, overwrite\n}\n\n// Get a value from the sorted map at key `k`. Returns false\n// if the key doesn't exist.\nfunc (r RedBlack) Get(k KType) (VType, bool) {\n\treturn r.loopGet(r.root, k)\n}\n\nfunc (r RedBlack) loopGet(h *mapnode, k KType) (v VType, ok bool) {\n\tfor h != nil {\n\t\tcmp := r.compare(k, h.key)\n\t\tif cmp == 0 {\n\t\t\treturn h.val, true\n\t\t} else if cmp < 0 {\n\t\t\th = h.left\n\t\t} else if cmp > 0 {\n\t\t\th = h.right\n\t\t}\n\t}\n\treturn\n}\n\n// Has tells if a value exists at key `k`. This is short hand for `Get.\nfunc (r RedBlack) Has(k KType) bool {\n\t_, ok := r.loopGet(r.root, k)\n\treturn ok\n}\n\n// Min returns the smallest key/value in the sorted map, if it exists.\nfunc (r RedBlack) Min() (k KType, v VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := r.min(r.root)\n\treturn h.key, h.val, true\n}\n\nfunc (r RedBlack) min(x *mapnode) *mapnode {\n\tif x.left == nil {\n\t\treturn x\n\t}\n\treturn r.min(x.left)\n}\n\n// Max returns the largest key/value in the sorted map, if it exists.\nfunc (r RedBlack) Max() (k KType, v VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := r.max(r.root)\n\treturn h.key, h.val, true\n}\n\nfunc (r RedBlack) max(x *mapnode) *mapnode {\n\tif x.right == nil {\n\t\treturn x\n\t}\n\treturn r.max(x.right)\n}\n\n// Floor returns the largest key/value in the sorted map that is smaller than\n// `k`.\nfunc (r RedBlack) Floor(key KType) (k KType, v VType, ok bool) {\n\tx := r.floor(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc (r RedBlack) floor(h *mapnode, k KType) *mapnode {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp < 0 {\n\t\treturn r.floor(h.left, k)\n\t}\n\tt := r.floor(h.right, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Ceiling returns the smallest key/value in the sorted map that is larger than\n// `k`.\nfunc (r RedBlack) Ceiling(key KType) (k KType, v VType, ok bool) {\n\tx := r.ceiling(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc (r RedBlack) ceiling(h *mapnode, k KType) *mapnode {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp > 0 {\n\t\treturn r.ceiling(h.right, k)\n\t}\n\tt := r.ceiling(h.left, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Select key of rank k, meaning the k-th biggest KType in the sorted map.\nfunc (r RedBlack) Select(key int) (k KType, v VType, ok bool) {\n\tx := r.nodeselect(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, x.val, true\n}\n\nfunc (r RedBlack) nodeselect(x *mapnode, k int) *mapnode {\n\tif x == nil {\n\t\treturn nil\n\t}\n\tt := x.left.size()\n\tif t > k {\n\t\treturn r.nodeselect(x.left, k)\n\t} else if t < k {\n\t\treturn r.nodeselect(x.right, k-t-1)\n\t} else {\n\t\treturn x\n\t}\n}\n\n// Rank is the number of keys less than `k`.\nfunc (r RedBlack) Rank(k KType) int {\n\treturn r.keyrank(k, r.root)\n}\n\nfunc (r RedBlack) keyrank(k KType, h *mapnode) int {\n\tif h == nil {\n\t\treturn 0\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp < 0 {\n\t\treturn r.keyrank(k, h.left)\n\t} else if cmp > 0 {\n\t\treturn 1 + h.left.size() + r.keyrank(k, h.right)\n\t} else {\n\t\treturn h.left.size()\n\t}\n}\n\n// Keys visit each keys in the sorted map, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) Keys(visit func(KType, VType) bool) {\n\tmin, _, ok := r.Min()\n\tif !ok {\n\t\treturn\n\t}\n\t// if the min exists, then the max must exist\n\tmax, _, _ := r.Max()\n\tr.RangedKeys(min, max, visit)\n}\n\n// RangedKeys visit each keys between lo and hi in the sorted map, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) RangedKeys(lo, hi KType, visit func(KType, VType) bool) {\n\tr.keys(r.root, visit, lo, hi)\n}\n\nfunc (r RedBlack) keys(h *mapnode, visit func(KType, VType) bool, lo, hi KType) bool {\n\tif h == nil {\n\t\treturn true\n\t}\n\tcmplo := r.compare(lo, h.key)\n\tcmphi := r.compare(hi, h.key)\n\tif cmplo < 0 {\n\t\tif !r.keys(h.left, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmplo <= 0 && cmphi >= 0 {\n\t\tif !visit(h.key, h.val) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmphi > 0 {\n\t\tif !r.keys(h.right, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// DeleteMin removes the smallest key and its value from the sorted map.\nfunc (r *RedBlack) DeleteMin() (oldk KType, oldv VType, ok bool) {\n\tr.root, oldk, oldv, ok = r.deleteMin(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) deleteMin(h *mapnode) (_ *mapnode, oldk KType, oldv VType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, oldv, false\n\t}\n\n\tif h.left == nil {\n\t\treturn nil, h.key, h.val, true\n\t}\n\tif !h.left.isRed() && !h.left.left.isRed() {\n\t\th = r.moveRedLeft(h)\n\t}\n\th.left, oldk, oldv, ok = r.deleteMin(h.left)\n\treturn r.balance(h), oldk, oldv, ok\n}\n\n// DeleteMax removes the largest key and its value from the sorted map.\nfunc (r *RedBlack) DeleteMax() (oldk KType, oldv VType, ok bool) {\n\tr.root, oldk, oldv, ok = r.deleteMax(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) deleteMax(h *mapnode) (_ *mapnode, oldk KType, oldv VType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, oldv, ok\n\t}\n\tif h.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.right == nil {\n\t\treturn nil, h.key, h.val, true\n\t}\n\tif !h.right.isRed() && !h.right.left.isRed() {\n\t\th = r.moveRedRight(h)\n\t}\n\th.right, oldk, oldv, ok = r.deleteMax(h.right)\n\treturn r.balance(h), oldk, oldv, ok\n}\n\n// Delete key `k` from sorted map, if it exists.\nfunc (r *RedBlack) Delete(k KType) (old VType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\tr.root, old, ok = r.delete(r.root, k)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) delete(h *mapnode, k KType) (_ *mapnode, old VType, ok bool) {\n\n\tif h == nil {\n\t\treturn h, old, false\n\t}\n\n\tif r.compare(k, h.key) < 0 {\n\t\tif h.left == nil {\n\t\t\treturn h, old, false\n\t\t}\n\n\t\tif !h.left.isRed() && !h.left.left.isRed() {\n\t\t\th = r.moveRedLeft(h)\n\t\t}\n\n\t\th.left, old, ok = r.delete(h.left, k)\n\t\th = r.balance(h)\n\t\treturn h, old, ok\n\t}\n\n\tif h.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\n\tif r.compare(k, h.key) == 0 && h.right == nil {\n\t\treturn nil, h.val, true\n\t}\n\n\tif h.right != nil && !h.right.isRed() && !h.right.left.isRed() {\n\t\th = r.moveRedRight(h)\n\t}\n\n\tif r.compare(k, h.key) == 0 {\n\n\t\tvar subk KType\n\t\tvar subv VType\n\t\th.right, subk, subv, ok = r.deleteMin(h.right)\n\n\t\told, h.key, h.val = h.val, subk, subv\n\t\tok = true\n\t} else {\n\t\th.right, old, ok = r.delete(h.right, k)\n\t}\n\n\th = r.balance(h)\n\treturn h, old, ok\n}\n\n// deletions\n\nfunc (r *RedBlack) moveRedLeft(h *mapnode) *mapnode {\n\tr.flipColors(h)\n\tif h.right.left.isRed() {\n\t\th.right = r.rotateRight(h.right)\n\t\th = r.rotateLeft(h)\n\t\tr.flipColors(h)\n\t}\n\treturn h\n}\n\nfunc (r *RedBlack) moveRedRight(h *mapnode) *mapnode {\n\tr.flipColors(h)\n\tif h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t\tr.flipColors(h)\n\t}\n\treturn h\n}\n\nfunc (r *RedBlack) balance(h *mapnode) *mapnode {\n\tif h.right.isRed() {\n\t\th = r.rotateLeft(h)\n\t}\n\tif h.left.isRed() && h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.left.isRed() && h.right.isRed() {\n\t\tr.flipColors(h)\n\t}\n\th.n = h.left.size() + h.right.size() + 1\n\treturn h\n}\n\nfunc (r *RedBlack) rotateLeft(h *mapnode) *mapnode {\n\tx := h.right\n\th.right = x.left\n\tx.left = h\n\tx.colorRed = h.colorRed\n\th.colorRed = true\n\tx.n = h.n\n\th.n = 1 + h.left.size() + h.right.size()\n\treturn x\n}\n\nfunc (r *RedBlack) rotateRight(h *mapnode) *mapnode {\n\tx := h.left\n\th.left = x.right\n\tx.right = h\n\tx.colorRed = h.colorRed\n\th.colorRed = true\n\tx.n = h.n\n\th.n = 1 + h.left.size() + h.right.size()\n\treturn x\n}\n\nfunc (r *RedBlack) flipColors(h *mapnode) {\n\th.colorRed = !h.colorRed\n\th.left.colorRed = !h.left.colorRed\n\th.right.colorRed = !h.right.colorRed\n}\n\n// nodes\n\ntype mapnode struct {\n\tkey         KType\n\tval         VType\n\tleft, right *mapnode\n\tn           int\n\tcolorRed    bool\n}\n\nfunc (x *mapnode) isRed() bool { return (x != nil) && (x.colorRed == true) }\n\nfunc (x *mapnode) size() int {\n\tif x == nil {\n\t\treturn 0\n\t}\n\treturn x.n\n}\n"
	redblackbstSetSrc = "package redblackbst\n\nfunc (r RedBlack) compare(a, b KType) int { return a.Compare(b) }\n\n// RedBlack is a sorted set built on a left leaning red black balanced\n// search sorted set. It stores unique KType values.\ntype RedBlack struct {\n\troot *treenode\n}\n\n// NewRedBlack creates a sorted set.\nfunc NewRedBlack() *RedBlack { return &RedBlack{} }\n\n// IsEmpty tells if the sorted set contains no key.\nfunc (r RedBlack) IsEmpty() bool {\n\treturn r.root == nil\n}\n\n// Size of the sorted set.\nfunc (r RedBlack) Size() int { return r.root.size() }\n\n// Clear all the values in the sorted set.\nfunc (r *RedBlack) Clear() { r.root = nil }\n\n// Put the key `k` in the sorted set. If the value was already there,\n// true is returned.\nfunc (r *RedBlack) Put(k KType) (already bool) {\n\tr.root, already = r.put(r.root, k)\n\treturn\n}\n\nfunc (r *RedBlack) put(h *treenode, k KType) (_ *treenode, already bool) {\n\tif h == nil {\n\t\tn := &treenode{key: k, n: 1, colorRed: true}\n\t\treturn n, already\n\t}\n\n\tcmp := r.compare(k, h.key)\n\tif cmp < 0 {\n\t\th.left, already = r.put(h.left, k)\n\t} else if cmp > 0 {\n\t\th.right, already = r.put(h.right, k)\n\t} else {\n\t\talready = true\n\t}\n\n\tif h.right.isRed() && !h.left.isRed() {\n\t\th = r.rotateLeft(h)\n\t}\n\tif h.left.isRed() && h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.left.isRed() && h.right.isRed() {\n\t\tr.flipColors(h)\n\t}\n\th.n = h.left.size() + h.right.size() + 1\n\treturn h, already\n}\n\n// Contains tells if `k` is a member of the set.\nfunc (r RedBlack) Contains(k KType) bool {\n\treturn r.loopContains(r.root, k)\n}\n\nfunc (r RedBlack) loopContains(h *treenode, k KType) (ok bool) {\n\tfor h != nil {\n\t\tcmp := r.compare(k, h.key)\n\t\tif cmp == 0 {\n\t\t\treturn true\n\t\t} else if cmp < 0 {\n\t\t\th = h.left\n\t\t} else if cmp > 0 {\n\t\t\th = h.right\n\t\t}\n\t}\n\treturn\n}\n\n// Min returns the smallest key in the sorted set, if it exists.\nfunc (r RedBlack) Min() (k KType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := r.min(r.root)\n\treturn h.key, true\n}\n\nfunc (r RedBlack) min(x *treenode) *treenode {\n\tif x.left == nil {\n\t\treturn x\n\t}\n\treturn r.min(x.left)\n}\n\n// Max returns the largest key in the sorted set, if it exists.\nfunc (r RedBlack) Max() (k KType, ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\th := r.max(r.root)\n\treturn h.key, true\n}\n\nfunc (r RedBlack) max(x *treenode) *treenode {\n\tif x.right == nil {\n\t\treturn x\n\t}\n\treturn r.max(x.right)\n}\n\n// Floor returns the largest key in the sorted set that is smaller than\n// `k`.\nfunc (r RedBlack) Floor(key KType) (k KType, ok bool) {\n\tx := r.floor(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, true\n}\n\nfunc (r RedBlack) floor(h *treenode, k KType) *treenode {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp < 0 {\n\t\treturn r.floor(h.left, k)\n\t}\n\tt := r.floor(h.right, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Ceiling returns the smallest key in the sorted set that is larger than\n// `k`.\nfunc (r RedBlack) Ceiling(key KType) (k KType, ok bool) {\n\tx := r.ceiling(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, true\n}\n\nfunc (r RedBlack) ceiling(h *treenode, k KType) *treenode {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp == 0 {\n\t\treturn h\n\t}\n\tif cmp > 0 {\n\t\treturn r.ceiling(h.right, k)\n\t}\n\tt := r.ceiling(h.left, k)\n\tif t != nil {\n\t\treturn t\n\t}\n\treturn h\n}\n\n// Select key of rank k, meaning the k-th biggest KType in the sorted set.\nfunc (r RedBlack) Select(key int) (k KType, ok bool) {\n\tx := r.nodeselect(r.root, key)\n\tif x == nil {\n\t\treturn\n\t}\n\treturn x.key, true\n}\n\nfunc (r RedBlack) nodeselect(x *treenode, k int) *treenode {\n\tif x == nil {\n\t\treturn nil\n\t}\n\tt := x.left.size()\n\tif t > k {\n\t\treturn r.nodeselect(x.left, k)\n\t} else if t < k {\n\t\treturn r.nodeselect(x.right, k-t-1)\n\t} else {\n\t\treturn x\n\t}\n}\n\n// Rank is the number of keys less than `k`.\nfunc (r RedBlack) Rank(k KType) int {\n\treturn r.keyrank(k, r.root)\n}\n\nfunc (r RedBlack) keyrank(k KType, h *treenode) int {\n\tif h == nil {\n\t\treturn 0\n\t}\n\tcmp := r.compare(k, h.key)\n\tif cmp < 0 {\n\t\treturn r.keyrank(k, h.left)\n\t} else if cmp > 0 {\n\t\treturn 1 + h.left.size() + r.keyrank(k, h.right)\n\t} else {\n\t\treturn h.left.size()\n\t}\n}\n\n// Keys visit each keys in the sorted set, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) Keys(visit func(KType) bool) {\n\tmin, ok := r.Min()\n\tif !ok {\n\t\treturn\n\t}\n\t// if the min exists, then the max must exist\n\tmax, _ := r.Max()\n\tr.RangedKeys(min, max, visit)\n}\n\n// RangedKeys visit each keys between lo and hi in the sorted set, in order.\n// It stops when visit returns false.\nfunc (r RedBlack) RangedKeys(lo, hi KType, visit func(KType) bool) {\n\tr.keys(r.root, visit, lo, hi)\n}\n\nfunc (r RedBlack) keys(h *treenode, visit func(KType) bool, lo, hi KType) bool {\n\tif h == nil {\n\t\treturn true\n\t}\n\tcmplo := r.compare(lo, h.key)\n\tcmphi := r.compare(hi, h.key)\n\tif cmplo < 0 {\n\t\tif !r.keys(h.left, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmplo <= 0 && cmphi >= 0 {\n\t\tif !visit(h.key) {\n\t\t\treturn false\n\t\t}\n\t}\n\tif cmphi > 0 {\n\t\tif !r.keys(h.right, visit, lo, hi) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// DeleteMin removes the smallest key from the sorted set.\nfunc (r *RedBlack) DeleteMin() (oldk KType, ok bool) {\n\tr.root, oldk, ok = r.deleteMin(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) deleteMin(h *treenode) (_ *treenode, oldk KType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, false\n\t}\n\n\tif h.left == nil {\n\t\treturn nil, h.key, true\n\t}\n\tif !h.left.isRed() && !h.left.left.isRed() {\n\t\th = r.moveRedLeft(h)\n\t}\n\th.left, oldk, ok = r.deleteMin(h.left)\n\treturn r.balance(h), oldk, ok\n}\n\n// DeleteMax removes the largest key from the sorted set.\nfunc (r *RedBlack) DeleteMax() (oldk KType, ok bool) {\n\tr.root, oldk, ok = r.deleteMax(r.root)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) deleteMax(h *treenode) (_ *treenode, oldk KType, ok bool) {\n\tif h == nil {\n\t\treturn nil, oldk, ok\n\t}\n\tif h.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.right == nil {\n\t\treturn nil, h.key, true\n\t}\n\tif !h.right.isRed() && !h.right.left.isRed() {\n\t\th = r.moveRedRight(h)\n\t}\n\th.right, oldk, ok = r.deleteMax(h.right)\n\treturn r.balance(h), oldk, ok\n}\n\n// Delete key `k` from sorted set, if it exists.\nfunc (r *RedBlack) Delete(k KType) (ok bool) {\n\tif r.root == nil {\n\t\treturn\n\t}\n\tr.root, ok = r.delete(r.root, k)\n\tif !r.IsEmpty() {\n\t\tr.root.colorRed = false\n\t}\n\treturn\n}\n\nfunc (r *RedBlack) delete(h *treenode, k KType) (_ *treenode, ok bool) {\n\n\tif h == nil {\n\t\treturn h, false\n\t}\n\n\tif r.compare(k, h.key) < 0 {\n\t\tif h.left == nil {\n\t\t\treturn h, false\n\t\t}\n\n\t\tif !h.left.isRed() && !h.left.left.isRed() {\n\t\t\th = r.moveRedLeft(h)\n\t\t}\n\n\t\th.left, ok = r.delete(h.left, k)\n\t\th = r.balance(h)\n\t\treturn h, ok\n\t}\n\n\tif h.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\n\tif r.compare(k, h.key) == 0 && h.right == nil {\n\t\treturn nil, true\n\t}\n\n\tif h.right != nil && !h.right.isRed() && !h.right.left.isRed() {\n\t\th = r.moveRedRight(h)\n\t}\n\n\tif r.compare(k, h.key) == 0 {\n\n\t\tvar subk KType\n\t\th.right, subk, ok = r.deleteMin(h.right)\n\t\th.key = subk\n\t\tok = true\n\t} else {\n\t\th.right, ok = r.delete(h.right, k)\n\t}\n\n\th = r.balance(h)\n\treturn h, ok\n}\n\n// deletions\n\nfunc (r *RedBlack) moveRedLeft(h *treenode) *treenode {\n\tr.flipColors(h)\n\tif h.right.left.isRed() {\n\t\th.right = r.rotateRight(h.right)\n\t\th = r.rotateLeft(h)\n\t\tr.flipColors(h)\n\t}\n\treturn h\n}\n\nfunc (r *RedBlack) moveRedRight(h *treenode) *treenode {\n\tr.flipColors(h)\n\tif h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t\tr.flipColors(h)\n\t}\n\treturn h\n}\n\nfunc (r *RedBlack) balance(h *treenode) *treenode {\n\tif h.right.isRed() {\n\t\th = r.rotateLeft(h)\n\t}\n\tif h.left.isRed() && h.left.left.isRed() {\n\t\th = r.rotateRight(h)\n\t}\n\tif h.left.isRed() && h.right.isRed() {\n\t\tr.flipColors(h)\n\t}\n\th.n = h.left.size() + h.right.size() + 1\n\treturn h\n}\n\nfunc (r *RedBlack) rotateLeft(h *treenode) *treenode {\n\tx := h.right\n\th.right = x.left\n\tx.left = h\n\tx.colorRed = h.colorRed\n\th.colorRed = true\n\tx.n = h.n\n\th.n = 1 + h.left.size() + h.right.size()\n\treturn x\n}\n\nfunc (r *RedBlack) rotateRight(h *treenode) *treenode {\n\tx := h.left\n\th.left = x.right\n\tx.right = h\n\tx.colorRed = h.colorRed\n\th.colorRed = true\n\tx.n = h.n\n\th.n = 1 + h.left.size() + h.right.size()\n\treturn x\n}\n\nfunc (r *RedBlack) flipColors(h *treenode) {\n\th.colorRed = !h.colorRed\n\th.left.colorRed = !h.left.colorRed\n\th.right.colorRed = !h.right.colorRed\n}\n\n// nodes\n\ntype treenode struct {\n\tkey         KType\n\tleft, right *treenode\n\tn           int\n\tcolorRed    bool\n}\n\nfunc (x *treenode) isRed() bool { return (x != nil) && (x.colorRed == true) }\n\nfunc (x *treenode) size() int {\n\tif x == nil {\n\t\treturn 0\n\t}\n\treturn x.n\n}\n"
	heapSrc           = "package heap\n\n// Most of the implementation is adapted from Algorithms 4ed by Sedgewick\n// and Wayne.\n\n// Comments are adapted from `container/heap`.\n// \t Copyright 2009 The Go Authors. All rights reserved.\n// \t Use of this source code is governed by a BSD-style\n// \t license that can be found in the LICENSE file.\n\nfunc (h Heap) compare(a, b KType) int { return a.Compare(b) }\n\n// Heap is a container of KType, where the elements can be efficiently\n// retrieved in their decreasing order (according to their comparison\n// rules).\ntype Heap struct {\n\tn  int\n\tpq []KType\n}\n\n// NewHeap creates a heap, optionaly with keys already populating\n// it. The complexity is O(n) where n = len(keys).\nfunc NewHeap(keys ...KType) *Heap {\n\th := &Heap{\n\t\tn:  len(keys),\n\t\tpq: append(make([]KType, 1), keys...),\n\t}\n\th.Fix()\n\treturn h\n}\n\n// Len is the number of elements stored in the heap.\nfunc (h *Heap) Len() int { return h.n }\n\n// Peek at the largest element (according to their comparison rules), without\n// removing it from the heap.\nfunc (h *Heap) Peek() KType { return h.pq[1] }\n\n// Fix re-establishes the heap ordering. This is useful if elements\n// of the heap have had their comparison value changed. It is equivalent to,\n// but less expenasive than, Pop'ing all the elements and Push'ing them\n// again.\n// The complexity is O(n).\nfunc (h *Heap) Fix() {\n\tfor i := (h.n) / 2; i > 0; i-- {\n\t\th.sink(i, h.n)\n\t}\n}\n\n// Push pushes the element k onto the heap. The complexity is\n// O(log(n)) where n == h.Len().\nfunc (h *Heap) Push(k KType) {\n\th.n++\n\th.pq = append(h.pq, k)\n\th.swim(h.n)\n}\n\n// Pop removes the largest element (according to their comparison rules) from\n// the heap and returns it. The complexity is O(log(n)) where n == h.Len().\nfunc (h *Heap) Pop() KType {\n\tval := h.pq[1]\n\th.swap(1, h.n)\n\th.pq = h.pq[:h.n]\n\th.n--\n\th.sink(1, h.n)\n\n\treturn val\n}\n\n// Remove removes k from the heap, if it exists. Equality is defined by\n// Compare == 0.\n// The complexity is O(n+log(n)) where n == h.Len().\nfunc (h *Heap) Remove(k KType) bool {\n\n\tcmp := h.compare(h.pq[1], k)\n\tif cmp == 0 {\n\t\t_ = h.Pop()\n\t\treturn true\n\t}\n\tif cmp < 0 {\n\t\t// larger than largest, don't try to find it\n\t\treturn false\n\t}\n\n\ti := 0\n\tfor _, j := range h.pq[1:] {\n\t\ti++\n\t\tif h.compare(j, k) != 0 {\n\t\t\tcontinue\n\t\t}\n\t\th.swap(i, 1)\n\t\th.sink(i, h.n)\n\t\t_ = h.Pop()\n\t\treturn true\n\t}\n\t// not in the heap\n\treturn false\n}\n\nfunc (h *Heap) swap(i, j int)      { h.pq[i], h.pq[j] = h.pq[j], h.pq[i] }\nfunc (h *Heap) less(i, j int) bool { return h.compare(h.pq[i], h.pq[j]) < 0 }\n\nfunc (h *Heap) swim(k int) {\n\tfor k > 1 && h.less(k/2, k) {\n\t\th.swap(k/2, k)\n\t\tk = k / 2\n\t}\n}\n\nfunc (h *Heap) sink(k, n int) {\n\n\tfor k*2 <= n {\n\t\tj := 2 * k\n\t\tif j < n && h.less(j, j+1) {\n\t\t\tj++\n\t\t}\n\t\tif !h.less(k, j) {\n\t\t\tbreak\n\t\t}\n\t\th.swap(k, j)\n\t\tk = j\n\t}\n}\n"
	queueSrc          = "package queue\n\n// Implementation adapted from github.com/eapache/queue:\n//    The MIT License (MIT)\n//    Copyright (c) 2014 Evan Huus\n\nvar nilKType KType\n\n// Queue represents a single instance of the queue data structure.\ntype Queue struct {\n\tbuf               []KType\n\thead, tail, count int\n\tminlen            int\n}\n\n// NewQueue constructs and returns a new Queue with an initial capacity.\nfunc NewQueue(capacity int) *Queue {\n\t// min capacity of 16\n\tif capacity < 16 {\n\t\tcapacity = 16\n\t}\n\treturn &Queue{buf: make([]KType, capacity), minlen: capacity}\n}\n\n// Len returns the number of elements currently stored in the queue.\nfunc (q *Queue) Len() int {\n\treturn q.count\n}\n\n// Push puts an element on the end of the queue.\nfunc (q *Queue) Push(elem KType) {\n\tif q.count == len(q.buf) {\n\t\tq.resize()\n\t}\n\n\tq.buf[q.tail] = elem\n\tq.tail = (q.tail + 1) % len(q.buf)\n\tq.count++\n}\n\n// Peek returns the element at the head of the queue. This call panics\n// if the queue is empty.\nfunc (q *Queue) Peek() KType {\n\tif q.Len() <= 0 {\n\t\tpanic(\"queue: empty queue\")\n\t}\n\treturn q.buf[q.head]\n}\n\n// Get returns the element at index i in the queue. If the index is\n// invalid, the call will panic.\nfunc (q *Queue) Get(i int) KType {\n\tif i >= q.Len() || i < 0 {\n\t\tpanic(\"queue: index out of range\")\n\t}\n\tmodi := (q.head + i) % len(q.buf)\n\treturn q.buf[modi]\n}\n\n// Pop removes the element from the front of the queue.\n// This call panics if the queue is empty.\nfunc (q *Queue) Pop() KType {\n\tif q.Len() <= 0 {\n\t\tpanic(\"queue: empty queue\")\n\t}\n\tv := q.buf[q.head]\n\t// set to nil to avoid keeping reference to objects\n\t// that would otherwise be garbage collected\n\tq.buf[q.head] = nilKType\n\tq.head = (q.head + 1) % len(q.buf)\n\tq.count--\n\tif len(q.buf) > q.minlen && q.count*4 <= len(q.buf) {\n\t\tq.resize()\n\t}\n\treturn v\n}\n\nfunc (q *Queue) resize() {\n\tnewBuf := make([]KType, q.count*2)\n\n\tif q.tail > q.head {\n\t\tcopy(newBuf, q.buf[q.head:q.tail])\n\t} else {\n\t\tcopy(newBuf, q.buf[q.head:len(q.buf)])\n\t\tcopy(newBuf[len(q.buf)-q.head:], q.buf[:q.tail])\n\t}\n\n\tq.head = 0\n\tq.tail = q.count\n\tq.buf = newBuf\n}\n"
)
